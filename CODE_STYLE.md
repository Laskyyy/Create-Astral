# Code style

In order to make the source code readable, try to fit to these guidelines:

# Table of contents

1. [Naming variables](#1-naming-variables)
2. [Writing scripts](#2-writing-scripts)
3. [Type checking](#3-type-checking)
    1. [Setup](#31-setup)
    2. [Using types](#32-using-types)
    3. [Recommended VSCode settings](#33-recommended-vscode-settings)

## 1. Naming variables

- Names should describe what the purpose of the variable is.

```js
// Do this
items.forEach((item) => {
  //...
});

// Don't do this
items.forEach((e) => {
  //...
});
```

- Variables should be initialized using `let` and named using camelCase:

```js
let sandStack = Item.of("minecraft:sand", 64);
```

- Constants should be initialized using `const` and named using either camelCase or SCREAMING_SNAKE_CASE:

```js
const incompleteTransitionalCircuit = "createastral:incomplete_transitional_electronic_circuit";
const BUCKET = 81000;
```

- Functions should be named using camelCase:

```js
function itemCount(itemName, count) {
  // ...
}
```

- Classes should be named using PascalCase.  
KubeJS does not support the `class` keyword, so you must use constructor functions instead.
```js
function SequencedAssemblyBuilder(event, io) {
  this._event = event;
  // ...
}
```

- Java classes should be prepended with a `$` sign.

```js
const $DeferredRegister = java("dev.architectury.registry.registries.DeferredRegister");
```

## 2. Writing Scripts

- Wrap every script inside an Immediately Invoked Function Expression ([IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)). This ensures no variables leak into global scope unless you really intend to by assigning to the `global` object:

```js
// Example of an IIFE
(function () {
  const private = "I'm not global and thus accessible only in this script!";
  global.globalString = "I'm global and thus accessible in every script!";
})();
// IIFEs can be named
(function myScript() {
  // ...
})();
```

- For long lists of recipes, use an array of objects. Do not use arrays of arrays (tuples), as they are harder to document with JSDoc.

```js
// Do this
const hauntingRecipes = [
  {
    input: "naturalist:snail_shell",
    output: "minecraft:nautilus_shell",
  },
  // ...
];

hauntingRecipes.forEach((recipe) => {
  // ...
});
```

```js
// Don't do this
const hauntingRecipes = [
  ["naturalist:snail_shell", "minecraft:nautilus_shell"],
  // ...
];

hauntingRecipes.forEach((recipe) => {
  // ...
});
```

- For stacks of multiple items, prefer using `Item.of(item, count)` instead of `${count}x ${item}`, especially when you are dynamically creating the stacks. This makes it easier to type-check the source code against ProbeJS types.

```js
// Encouraged
{
  input: Item.of("techreborn:coal_dust", 2),
  output: "techreborn:coal_dust",
},
// Discouraged
{
  input: "2x minecraft:charcoal",
  output: "minecraft:coal",
},
```

- Use template literals instead of string concatenation whenever possible.
  This allows for type-checking all possible variants of a template literal against ProbeJS types.

```js
// TypeScript is able to type-check JavaScript code with JSDoc annotations.
// This one tells TypeScript that the array won't ever change, so each result can be type-checked.
const gems = /** @type {const} */ (["peridot", "red_garnet", "ruby", "sapphire", "yellow_garnet"]);
// Do this
gems.forEach((gem) => {
  HIDDEN_ITEMS.push(`techreborn:${gem}_storage_block`);
});

// Don't this
gems.forEach((gem) => {
  HIDDEN_ITEMS.push("techreborn:" + gem + "_storage_block");
});
```

- This repository defines constants and common code in the `global` object.  
  - `global.server` stores common constants and functions for server code.
  - `global.fluids` stores constants related to fluid amounts, like `BUCKET` or `mB`.
  - `global.startup` stores constants and functions for startup code.
- To access the constants, destructure the object inside the IIFE:  
```js
(function myScript() {
  const { createSequencedAssembly } = global.server
  const { BUCKET, mB } = global.fluids

  // ...
})();
```

## 3. Type checking

### 3.1. Setup

You can optionally type-check your script against ProbeJS scripts by doing the following:

- Add ProbeJS to the pack:  
  https://www.curseforge.com/minecraft/mc-mods/probejs/files/4365861
- Launch Minecraft
- For best possible dump:
  - `/kubejs reload client_scripts`
  - `/kubejs reload server_scripts`
  - `/kubejs reload startup_scripts`
  - Try to sleep in a bed
  - Right-click a block with an item
  - Left-click a block with an item
- Do `/probejs dump`
- Typings should appear in:

```
<instance>/minecraft/kubejs/probe/generated
```

Because ProbeJS exports typings for synthetic methods (for example generated by Mixin) that contain dashes in names, generated `globals.d.ts` is broken because in JavaScript methods can't have dashes in names.

- Open up `globals.d.ts` in a text editor that supports replacing by regular expression. Instructions will assume VS Code or similar editor.
- Click on the "Use regular expression" button.
- Replace all `(?<!")((?=\S*['-])(?:[a-zA-Z$\d_'-]+))(?!")(?=\()` with `"$1"`.
- There should be no more syntax errors.

Also, because ProbeJS tries and fails to type `global`:
- Open up `constants.d.ts`.
- Remove or comment out `type global = ...`.
- Now `global` should be properly inferred.

Then:

- Copy over the `probe` folder from the Minecraft instance to the repository. `probe` is in `.gitignore`, so it won't be included in your commits.
- Use the following command to stop changes to `kubejs/jsconfig.json` from being committed:
```sh
git update-index --assume-unchanged kubejs/jsconfig.json
```

(Later on, if you want to change something else than type-checking, use the following command.)
```sh
git update-index --no-assume-unchanged kubejs/jsconfig.json
```

- In `kubejs/jsconfig.json`, change the `checkJs` field from `false` to `true`.

And here you go! Now every JavaScript file will be type-checked against types from ProbeJS and custom declarations in this repository!

```js
(function myCoolScript() {
  let a = 5;
  a = "string";
  // ^ Error: Type 'string' is not assignable to type 'number'.
});
```

### 3.2. Using types

TypeScript can infer basic types from usage, but in many cases you will need to explicitly set the type of item using JSDoc comments.

Useful links:
- [JSDoc](https://jsdoc.app/)
- [TypeScript's extension to JSDoc](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)


Some basic syntax that is commonly used throughout the codebase:

#### Setting a type of the variable
```js
/** @type {Internal.IngredientJS_[]} */
let HIDDEN_ITEMS = [
  "ae2:silicon",
  "extended_drawers:t1_upgrade",
  "extended_drawers:t2_upgrade",
  //...
]
// Now HIDDEN_ITEMS is an array of anything that is Internal.IngredientJS_.
```
#### Defining types

##### Types

```ts
/** @typedef {"create:blaze_burner" | "createaddition:liquid_blaze_burner"} Burner */

// This is equivalent to the following TypeScript syntax:
type Burner = "create:blaze_burner" | "createaddition:liquid_blaze_burner"

// Now the type can be used in the script:
/** @type {Burner} */
let burner = "create:blaze_burner"
// Can only hold literal strings defined in the "Burner" type
```

##### Interfaces
Interfaces declare the shape of an object. They can be used as a type of variable or a constant.
```ts
/**
 * @typedef CrushingRecipeToBecomeGrinding
 * @property {object} input
 * @property {Special.Item} input.item
 * @property {object} output
 * @property {Special.Item} output.item
 * @property {number} output.count
 * @property {number} [time]
 * @property {number} [power]
 */
// Properties in square brackets are considered optional.

// This is equivalent to the following TypeScript syntax:
interface CrushingRecipeToBecomeGrinding {
  input: { item: Special.Item };
  output: { item: Special.Item; count: number };
  time?: number;
  power?: number;
}

// Now the type can be used in the script:

/** @type {CrushingRecipeToBecomeGrinding[]} */
const crushingRecipesToBecomeGrinding = [
  //...
]
```

#### Declaring a list immutable

```js
// @satisfies {string[]} ensures that the array is an array of strings without changing the array's type.
// @type {const} declares that the array won't ever change.
// Thanks to that, TypeScript can check for validity of strings in template literals more effectively.
// Mind the round brackets!
/** @satisfies {string[]} */
const names = /** @type {const} */ ([
  "helmet",
  "chestplate",
  "leggings",
  "boots",
  "sword",
  "pickaxe",
  "shovel",
  "axe",
  "hoe",
]);

```

#### Common types

- For items used in KubeJS functions, use types:
  - `Special.Item` - accepts only strings corresponding to items,
  - `Internal.ItemStackJS_` - accepts `Item`s and other strings corresponding to items.
  - `Internal.IngredientJS_` - a huge type that encompasses most things that can be ingredients.

Prefer using `Item.of("minecraft:apple", 5)` instead of `5x minecraft:apple` - the latter will throw an error when type checked.

- For fluids used in KubeJS functions, use types:
  - `Special.Fluid` - accepts only strings corresponding to fluids,
  - `{fluid: Special.Fluid, amount: number}` - accepts any object that conforms to this type.
  - `Internal.IngredientJS_` - a huge type that encompasses most things that can be ingredients.

### 3.3. Recommended VSCode settings

- **TypeScript › Tsserver › Experimental: Enable Project Diagnostics**: Enabled.

With this option, the entire project will be type-checked instead of just open files.
- **JavaScript › Inlay Hints › Function Like Return Types**: Enabled.
- **JavaScript › Inlay Hints › Parameter Types**: Enabled.
- **JavaScript › Inlay Hints › Property Declaration Types**: Enabled.
- **JavaScript › Inlay Hints › Variable Types**: Enabled.

These options will display hints based on inferred variable types.
